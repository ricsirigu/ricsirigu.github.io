{"componentChunkName":"component---src-templates-blog-post-index-tsx","path":"/blog/blog-post-8/","result":{"data":{"markdownRemark":{"html":"<p>Say you want to extend a particular class (type) with some new functionality but you can't access the source code..\nor perhaps you can but you don't want to use inheritance and subtype polimorphism..</p>\n<!--more-->   \n<p>Let's suppose you have the following type that represents an uploaded picture</p>\n<p>{% highlight scala %}\ncase class Picture(name: String, uri: Uri)<br>\n{% endhighlight %}</p>\n<p>and you want to return the json representation of it to your clients.<br>\nYou can do something like this</p>\n<p>{% highlight scala %}</p>\n<p>trait Jsonable{\ndef toJson: JValue\n}</p>\n<p>final case class Picture(name: String, uri: Uri) extends Jsonable{\ndef toJson(): JValue = {\n//implementation omitted\n}\n}<br>\n{% endhighlight %}</p>\n<p>Then you realize that you need another type, Attachment.<br>\nNo problem, let's add another case class to the mix</p>\n<p>{% highlight scala %}</p>\n<p>final case class Attachment(name: String, uri: Uri, visibile: Boolean) extends Jsonable{\ndef toJson(): JValue = {\n//implementation omitted\n}\n}<br>\n{% endhighlight %}</p>\n<p>Now you can serialize to json all of your case classes that extends the <em>Jsonable</em> trait</p>\n<p>{% highlight scala %}\nval picture: Jsonable = Picture(\"scalaitaly.png\", new Uri(\"aws.s3.scalaitaly.png\"))\nval attachment: Jsonable = Attachment(\"speakers.pdf\", new Uri(\"aws.s3.speakers.pdf\"), true)</p>\n<p>println(picture.toJson)\nprintln(attachment.toJson)\n{% endhighlight %}</p>\n<p>This all works, but what if you don't have access to the source code of <code>Picture</code> or <code>Attachment</code>?\nIs there another way? Maybe more <strong>Scala-ish</strong>?   </p>\n<h2>Type Classes to the rescue</h2>\n<p>First and foremost. A Type Class has nothing to do with the concept of class in a typical Object Oriented programming language.<br>\nIt's a concept from the Haskell world and it's used to achieve <strong>ad-hoc polymorphism</strong>  </p>\n<h3>Type Classes in practice</h3>\n<p>The first thing to do is define the behavior that you want your classes to have, in this case we want our case classes to be serializable in the json format.<br>\nThat's the Type Class.</p>\n<p>{% highlight scala %}\ntrait JsonWriter[T]{\ndef toJson(in: T): JValue\n}\n{% endhighlight %}</p>\n<p>then we need the Type Class instances for each concrete class we have</p>\n<p>{% highlight scala %}\nimplicit val pictureJsonWriter = new JsonWriter[Picture]{\noverride def toJson(in: Picture): JValue = ???\n}  </p>\n<p>implicit val attachmentJsonWriter = new JsonWriter[Attachment]{\noverride def toJson(in: Attachment): JValue = ???\n}\n{% endhighlight %}</p>\n<p>we mark them <code>implicit</code> because we want the compiler to be able to inject the correct implementation into the interface the we are defining next</p>\n<p>{% highlight scala %}\ndef jsonOf<a href=\"in:%20T\">T</a>(implicit jsonWriter: JsonWriter[T]): String =\njsonWriter.toJson(in)\n{% endhighlight %}</p>\n<p>You can play with the code below  </p>\n<iframe height=\"300\" frameborder=\"0\" style=\"width: 100%; overflow: hidden;\" src=\"https://embed.scalafiddle.io/embed?sfid=eRUVeR8/5&layout=v80\"></iframe>\n<p>Wouldn't it better if the method <code>toJson</code> would be a part of the classes in our domain model but without touching them?\nAdding the functionality magically from the outside.</p>\n<p>I would like to write</p>\n<p>{% highlight scala %}\nprintln(Picture(\"mypic\", \"mypicurl\").toJson)\nprintln(Attachment(\"myattachment\", \"myurl\", false).toJson)\n{% endhighlight %}</p>\n<p>As if <code>toJson</code> were a built-in method of the class.</p>\n<p>Yes, I know that, for example in Ruby, Javascript you can do monkey patching, but we are talking about compile time transformation, not runtime.</p>\n<p>In Scala you can achieve that using <strong>Implicit Classes</strong></p>\n<p>You just need to write </p>\n<p>{% highlight scala %}\nimplicit class JsonSerializer<a href=\"data:%20T\">T</a>{\ndef toJson(implicit writer: JsonWriter[T]): String =\nwriter.toJson(data)\n}\n{% endhighlight %}</p>\n<p>This way, when you try to do something like <code>Picture(\"mypic\", \"mypicurl\").toJson</code>, the compiler, not finding the <code>toJson</code> method in the <code>Picture</code> class, tries to convert <code>Picture</code> in a <code>JsonSerializer</code> that has the method you want.<br>\nThen it passes as <code>implicit writer: JsonWriter[T]</code> your Type Class instance that you defined for <code>Picture</code> before.  </p>\n<p>You can play with the final code below  </p>\n<iframe height=\"300\" frameborder=\"0\" style=\"width: 100%; overflow: hidden;\" src=\"https://embed.scalafiddle.io/embed?sfid=V6QiLPI/1&layout=v80\"></iframe>\n<h3>Conclusions</h3>\n<p>With this powerful design pattern we have achieved an impressive result.<br>\nWe can now add new data or new methods to existing types without changing any existing code.  </p>\n<p>It's certainly a design pattern that is useful to have in your toolbelt.<br>\nIt's so important that many famous libraries such as <a href=\"https://github.com/milessabin/shapeless\">Shapeless</a>{:target=\":blank\"}, <a href=\"http://typelevel.org/cats/\">Cats</a>{:target=\":blank\"}, <a href=\"https://github.com/scalaz/scalaz\">Scalaz</a>{:target=\":blank\"} and so on, couldn't even exists without this.</p>\n<p>If you want to learn more (yes you want) I suggest you <a href=\"http://underscore.io/books/advanced-scala/\">Advanced Scala</a>{:target=\"<em>blank\"} by the amazing guys of <a href=\"http://underscore.io/books/\">Underscore.io</a>{:target=\"</em>blank\"}.  </p>\n<p>Moreover, they recently open sourced all their ebooks, you can download all of them for free <a href=\"http://underscore.io/books/\">here</a>, what are you waiting for?</p>\n<p>Keep Learning<br>\nUntil next time</p>","frontmatter":{"title":"Type Classes in Scala: A Practical Example","date":"Jun 02, 2017"}}},"pageContext":{"slug":"/blog/blog-post-8/","previous":{"fields":{"slug":"/blog/functional-programming-and-category-theory/"},"frontmatter":{"title":"Functional Programming and Category Theory"}},"next":{"fields":{"slug":"/blog/blog-post-10/"},"frontmatter":{"title":"How to protect your RESTful APIs in Lift with JWT"}}}}}