{"componentChunkName":"component---src-templates-blog-post-index-tsx","path":"/blog/blog-post-2/","result":{"data":{"markdownRemark":{"html":"<p>I was digging around the source code of our project when I noticed spread in many <a href=\"http://exploring.liftweb.net/master/index-5.html\">snippets</a>{:target=\"_blank\"}, code that perform the same action (such as send a push notification to a user) after a particular object gets persisted in the database (for example when a new chat message is sent) or when a change of state happens (a payment for a particular order has been made).</p>\n<!--more-->   \n<p>The tecnhique I'm about to discuss can be applied to many frameworks: <strong>Java</strong> and <a href=\"https://docs.jboss.org/hibernate/entitymanager/3.5/reference/en/html/listeners.html\">hibernate</a>{:target=\"<em>blank\"}, <strong>Ruby</strong> with <a href=\"http://guides.rubyonrails.org/active_record_callbacks.html\">active record</a>{:target=\"</em>blank\"}, <strong>Meteor</strong> and its <a href=\"https://www.discovermeteor.com/blog/a-look-at-meteor-collection-hooks/\">collection hooks</a>{:target=\"_blank\"}, and for all the homo erectus who are reading, also with some Php framework, just to name a few.</p>\n<h2>Simplifying and DRYing out the code</h2>\n<p>The framework-agnostic recipe is the following:</p>\n<ul>\n<li><strong>Identify</strong> repeated code that perform some action after a change of state persisted on the database</li>\n<li><strong>Cut</strong> the previously identified code </li>\n<li><strong>Paste</strong> it in the model and override the lifecycle callback that make sense the most, as explained below</li>\n</ul>\n<p> In <a href=\"http://www.liftweb.net/\">Lift</a>{:target=\"<em>blank\"} we accomplish this with the LifecycleCallbacks <a href=\"http://docs.scala-lang.org/tutorials/tour/traits.html\">trait</a>{:target=\"</em>blank\"} that we can mix in the fields of our <a href=\"https://www.assembla.com/wiki/show/liftweb/Record\">record</a>{:target=\"<em>blank\"}, <a href=\"https://www.assembla.com/wiki/show/liftweb/Mongo_Record_Basics\">MongoRecord</a>{:target=\"</em>blank\"} in our case.\nThis trait make us available the following methods</p>\n<p> {% highlight scala %}</p>\n<p> def beforeValidation {}\ndef afterValidation {}</p>\n<p> def beforeSave {}\ndef beforeCreate {}\ndef beforeUpdate {}</p>\n<p> def afterSave {}\ndef afterCreate {}\ndef afterUpdate {}</p>\n<p> {% endhighlight %}</p>\n<p>that we can override in order to perform actions at various points during the lifecycle of a given instance. Their names are self explanatory but a thing to remember is that <code>beforeSave</code> is always called before <code>beforeCreate</code> or <code>beforeUpdate</code>.<br>\n<code>afterSave</code>, similarly, is called after <code>afterCreate</code> or <code>afterUpdate</code>.  </p>\n<p>With this tool in our toolbelt we can centralize the code that was spread all over the codebase, in our model, making our software more mantainable, <a href=\"https://en.wikipedia.org/wiki/Don%27t_repeat_yourself\">DRY</a>{:target=\"_blank\"}, and clean.</p>\n<p>Here is an example</p>\n<p> {% highlight scala %}\nclass ChatMsg extends MongoRecord[ChatMsg]\nwith ObjectIdPk[ChatMsg]{\ndef meta = ChatMsg\nobject text extends StringField(this, 500)\nwith LifecycleCallbacks{\noverride def afterSave: Unit = {\n//send push notification or whatever\n}\n}\n}\n{% endhighlight %}</p>\n<p>Go and try it out!<br>\nKeep Learning.<br>\nUntil next time</p>","frontmatter":{"title":"Scala & Lift and the record lifecycle callbacks","date":"Feb 29, 2016"}}},"pageContext":{"slug":"/blog/blog-post-2/","previous":null,"next":{"fields":{"slug":"/blog/blog-post-3/"},"frontmatter":{"title":"Isomorphic Web Applications with Scala and ScalaJs"}}}}}