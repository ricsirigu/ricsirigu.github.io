{"componentChunkName":"component---src-templates-blog-post-index-tsx","path":"/blog/blog-post-10/2017-07-21-lift-framework-rest-apis-authentication-with-jwt/","result":{"data":{"markdownRemark":{"html":"<p>You have a RESTful api as a source of data for your mobile applications or a reactjs/angular/vue/whatever frontend, and you, as a security conscious software engineer (or a good student that follows <a href=\"https://github.com/shieldfy/API-Security-Checklist\">these security guidelines</a>{:target=\"_blank\"} ) want to protect your precious endpoints from unwanted eyes.</p>\n<!--more-->   \n<img class=\"img-center\" src=\"{{site.url}}/assets/my-precious-rest-api.jpg\" alt=\"my treasure restful apis\">\n<h2>What is JWT</h2>\n<p>As explained in <a href=\"https://jwt.io/introduction/\">the official JWT page</a>{:target=\"<em>blank\"} or in the <a href=\"https://tools.ietf.org/html/rfc7519\">RFC 7519</a>{:target=\"</em>blank\"},</p>\n<p><em>JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA.</em></p>\n<p>In brief, it's a string with the following format</p>\n<p><code>header.payload.signature</code></p>\n<p>where each part is <strong>base64url</strong> encoded, interactive examples <a href=\"https://jwt.io/#debugger\">here</a>{:target=\"_blank\"}.</p>\n<p>Just rember that the payload is not encrypted and <strong>ANYONE</strong> that has access to the token can see what's inside. An attacker can inspect the payload but he can't tamper with it because it's signed with a <strong>STRONG</strong> key that you generated.</p>\n<p>My library of choice to encode/decode/verify JWT with Scala is <a href=\"http://pauldijou.fr/jwt-scala\">jwt-scala</a>{:target=\"_blank\"}</p>\n<h2>Building an interceptor with Lift</h2>\n<p>The api we want to protect is the following</p>\n<p><code>GET /api/secured/treasure</code></p>\n<p>I would like to have a middleware (in Express.js terms, a decorator if you are a Python lover) that intercepts every request that points to a protected resource, decode the JWT inside of the http request's <strong>Authorization</strong> header and allow or deny access to the forementioned resource according to the token validity.</p>\n<p><strong>How can we do this with Lift?</strong></p>\n<p>The <code>LiftRules</code> object is where most of the configuration parameters that handles HTTP request and responses reside.\nIt gets initialized during boot.</p>\n<p>As the <a href=\"https://exploring.liftweb.net/master/index-9.html#toc-Section-9.9\">documentation says</a>{:target:\"_blank\"}, this is the place where we tell Lift what resource needs to be protected and how.</p>\n<p>Lift doesn't support Token based authentication out of the box, but thanks to its extensibility we can easily write our own JWT authenticator.</p>\n<p>Let the fun begin!</p>\n<p>Let's start with informing Lift that out precious API needs to be protected.</p>\n<p>{% highlight scala %}\ndef protectedRoutes: LiftRules.HttpAuthProtectedResourcePF = {\n//Empty means that this resource is protected by authentication but no authorization is performed\ncase \"api\" :: \"secured\" :: \"treasure\" :: Nil JsonGet _ => Empty\n}\nLiftRules.httpAuthProtectedResource.append(protectedRoutes)\nLiftRules.authentication = JWTAuthentication(\"api\"){\ncase(payload, _) =>\ntrue\n}\n{% endhighlight %}</p>\n<p>For each <code>HttpAuthProtectedResourcePF</code> inside <code>LiftRules.httpAuthProtectedResource</code>, Lift will use the authentication mechanism defined with <code>LiftRules.authentication</code>.<br>\nIn our case <code>JWTAuthentication</code>.</p>\n<p>Let's write it.</p>\n<p>First thing to do, in order to tell Lift we are writing an HTTP authentication method, we must extend the <code>HttpAuthentication</code> trait</p>\n<p>{% highlight scala %}\ntrait HttpAuthentication {\ndef header(r: Req): Box[String] = r.request.header(\"Authorization\")</p>\n<p>  def verified_? : PartialFunction[Req, Boolean]</p>\n<p>  def realm: String = \"\"</p>\n<p>  def unauthorizedResponse: UnauthorizedResponse = UnauthorizedResponse(realm)</p>\n<p>  def shutDown {}\n}\n{% endhighlight %}</p>\n<p>and override the <code>verified_?</code> partial function, that is the bouncer of our API.</p>\n<p>Inside the <code>verified_?</code> partial function we need to take the token from the request's <code>Authorization</code> header, verify it and decode its payload, if we are interested in the claims inside its stomach.<br>\nIf <code>verified_?</code> returns <code>true</code>, the client is allowed, otherwise a 401 UnauthorizedResponse will be returned.</p>\n<p>{% highlight scala %}\ncase class JWTAuthentication(realmName: String)(func: PartialFunction[(String, Req), Boolean]) extends HttpAuthentication {\n...\n//If the credentials functions returns a Full box, func gets executed\noverride def verified_? : PartialFunction[Req, Boolean] = {\ncase (req) =>\ncredentials(req) match {\ncase Full(payload) if func.isDefinedAt(payload, req) =>\njwtClaims.set(Option(payload))\nfunc(payload, req)\ncase _ => false\n}\n}\n}\n{% endhighlight %}</p>\n<p><code>credentials</code> is a simple function that decodes the JWT with your secret and a given algorithm, you can find the full code at the end of this post.</p>\n<p>Now we have an interceptor that can extract a JWT from each request that points to a protected resource, but how can we examine the claims that are inside the token without redoing the work that our interceptor has already done? </p>\n<p>It's simple, we can stick our decoded payload in a <code>TransientRequestVar</code>, a request variable that has the scope of the current HTTP request.</p>\n<p>{% highlight scala %}\nobject jwtClaims extends TransientRequestVar<a href=\"Empty\">Option[String]</a>\n{% endhighlight %}</p>\n<p>Now in our api we can access jwtClaims and analyze the JWT payload.\n{% highlight scala %}\nobject SecuredApi extends RestHelper{\nserve(\"api\" / \"secured\" prefix {\ncase \"treasure\" :: Nil JsonGet _ =>\n//Here you can access jwtClaims TransientRequestVar\nJString(\"My Treasure\")\n})\n}\n{% endhighlight %}</p>\n<p>This example is purposefully simple in order to make you better understand the general architecture, a better approach would be deserialize our claims and stick inside the TransientRequestVar not a String but a more suitable and easier to manage data type.</p>\n<p>Here below, for your enjoyment, the full source code.</p>\n<p>{% gist 5fb7a57f8af53f93b76d344a5422bf3f SecuredApi.scala %}</p>\n<p>{% gist 5fb7a57f8af53f93b76d344a5422bf3f JWTAuthentication.scala %}</p>\n<p>Keep Learning<br>\nUntil next time</p>","frontmatter":{"title":"How to protect your RESTful APIs in Lift with JWT","date":"Jul 21, 2017"}}},"pageContext":{"slug":"/blog/blog-post-10/2017-07-21-lift-framework-rest-apis-authentication-with-jwt/","previous":{"fields":{"slug":"/blog/blog-post-10/"},"frontmatter":{"title":"How to protect your RESTful APIs in Lift with JWT"}},"next":{"fields":{"slug":"/blog/blog-post-11/"},"frontmatter":{"title":"Blog Post 5"}}}}}